# Story 2.2: Finance View Data Layer & API

## Status
Done

## Story
**As a** developer,
**I want** SQL query functions and an API endpoint that aggregate event data into Finance view metrics,
**so that** I can provide P&L, cash flow, and cost analysis data to the frontend.

## Acceptance Criteria

1. Query utility file `lib/queries/finance-queries.ts` created with functions:
   - `getPLSummary(scenarioId)`: Returns `{ revenue: number, payroll: number, cogs: number, profit: number }`
   - `getMonthlyCashFlow(scenarioId)`: Returns array of `{ month: Date, cashIn: number, cashOut: number, netCash: number }`
   - `getCostBreakdown(scenarioId)`: Returns cost categories (payroll, procurement, other) with amounts
   - `getMarginAnalysis(scenarioId)`: Returns gross margin, net margin percentages
2. All query functions use Prisma with proper aggregations (SUM, GROUP BY)
3. API route `/api/views/finance` created accepting GET request with query param `scenarioId`
4. Endpoint returns JSON with structure: `{ plSummary: {}, monthlyCashFlow: [], costBreakdown: {}, marginAnalysis: {} }`
5. Manual test verifies Finance revenue matches Sales revenue (consistency check from Epic 1 validation)

## Tasks / Subtasks

- [ ] Create Finance Query Utility Module (AC: 1, 2)
  - [ ] Create file `lib/queries/finance-queries.ts`
  - [ ] Import Prisma client: `import { prisma } from '@/lib/db'` and Decimal types
  - [ ] Implement `getPLSummary(scenarioId: string)` function
    - Query events for scenarioId
    - Calculate revenue: SUM(amountEur) where eventType = 'sales_transaction'
    - Calculate payroll: SUM(ABS(amountEur)) where eventType = 'employee_lifecycle' and metadata.category = 'payroll'
    - Calculate COGS: SUM(ABS(amountEur)) where eventType = 'procurement' and metadata.category = 'materials'
    - Calculate profit: revenue - payroll - cogs - other expenses
    - Return object with all 4 metrics
  - [ ] Implement `getMonthlyCashFlow(scenarioId: string)` function
    - Query events grouped by timePeriod
    - cashIn: SUM(amountEur) where amountEur > 0 (positive amounts)
    - cashOut: SUM(ABS(amountEur)) where amountEur < 0 (negative amounts)
    - netCash: cashIn - cashOut
    - Return array sorted chronologically
  - [ ] Implement `getCostBreakdown(scenarioId: string)` function
    - Group costs by category: payroll, procurement, other
    - Calculate SUM for each category
    - Return object with category totals and percentages
  - [ ] Implement `getMarginAnalysis(scenarioId: string)` function
    - Use getPLSummary() results
    - Calculate grossMargin: (revenue - cogs) / revenue * 100
    - Calculate netMargin: profit / revenue * 100
    - Return object with both percentages
  - [ ] Add TypeScript return types for all functions
  - [ ] Add JSDoc comments documenting financial calculations

- [ ] Create TypeScript Types for Finance View (AC: 4)
  - [ ] Update `types/api.ts`
  - [ ] Define `PLSummary` interface: `{ revenue: number; payroll: number; cogs: number; profit: number }`
  - [ ] Define `MonthlyCashFlow` interface: `{ month: Date; cashIn: number; cashOut: number; netCash: number }`
  - [ ] Define `CostBreakdown` interface: `{ payroll: number; procurement: number; other: number; payrollPercent: number; procurementPercent: number; otherPercent: number }`
  - [ ] Define `MarginAnalysis` interface: `{ grossMargin: number; netMargin: number }`
  - [ ] Define `FinanceViewResponse` interface combining all types

- [ ] Create Finance View API Endpoint (AC: 3, 4)
  - [ ] Create directory `app/api/views/finance/` if it doesn't exist
  - [ ] Create file `app/api/views/finance/route.ts`
  - [ ] Import Next.js utilities and finance query functions
  - [ ] Implement GET handler: `export async function GET(request: NextRequest)`
  - [ ] Extract and validate scenarioId from query params
  - [ ] Call all 4 query functions in parallel using `Promise.all()`
  - [ ] Construct FinanceViewResponse object
  - [ ] Return JSON response with 200 status
  - [ ] Add error handling for database errors (return 500)
  - [ ] Use TypeScript strict types throughout

- [ ] Cross-View Consistency Validation (AC: 5)
  - [ ] After implementing Finance queries, manually test consistency
  - [ ] Generate a scenario using `/api/generate`
  - [ ] Fetch Sales revenue: `curl .../api/views/sales?scenarioId=X`
  - [ ] Fetch Finance revenue: `curl .../api/views/finance?scenarioId=X`
  - [ ] Verify plSummary.revenue equals sum of Sales revenueByMonth
  - [ ] Document any discrepancies (should be zero due to Story 1.8 validation)
  - [ ] Add comment in code referencing validation from Story 1.8

- [ ] Error Handling & Input Validation (AC: 3)
  - [ ] Validate scenarioId format (UUID)
  - [ ] Handle missing scenarioId (return 400)
  - [ ] Handle nonexistent scenario (return empty/zero values, not error)
  - [ ] Add try-catch for Prisma errors
  - [ ] Test error cases: missing/invalid/nonexistent scenarioId

- [ ] Manual Testing & Verification (AC: 5)
  - [ ] Generate Bakery scenario
  - [ ] Test Finance API: `curl http://localhost:3000/api/views/finance?scenarioId={uuid}`
  - [ ] Verify P&L summary calculations (spot-check revenue = sum of sales)
  - [ ] Verify cash flow aggregations (cashIn + cashOut = total)
  - [ ] Verify margin calculations (grossMargin formula correct)
  - [ ] Test error cases (missing/invalid scenarioId)

- [ ] Unit Tests (AC: 2)
  - [ ] Create test file `lib/queries/__tests__/finance-queries.test.ts`
  - [ ] Mock Prisma client using `vi.mock('@/lib/db')`
  - [ ] Test `getPLSummary()`: verify revenue, costs, profit calculations
  - [ ] Test `getMonthlyCashFlow()`: verify cash in/out segregation
  - [ ] Test `getCostBreakdown()`: verify category grouping
  - [ ] Test `getMarginAnalysis()`: verify margin percentage calculations
  - [ ] Test edge cases: zero revenue (margin = 0), negative amounts, empty events
  - [ ] Run `pnpm test` and verify 80%+ coverage

## Dev Notes

### Database Schema
[Source: prisma/schema.prisma]

**Event Model Fields (relevant for finance queries):**
- `eventType`: String - filter for 'sales_transaction', 'employee_lifecycle', 'procurement'
- `amountEur`: Decimal(12,2) - positive for revenue, negative for expenses
- `timePeriod`: String - "2024-01" format for monthly aggregations
- `metadata`: JSON - contains `{ category: 'payroll' | 'materials' | 'other' }` for cost categorization

**Event Types for Finance View:**
1. **Revenue**: `eventType = 'sales_transaction'` → positive amountEur
2. **Payroll**: `eventType = 'employee_lifecycle'` → negative amountEur, metadata.category = 'payroll'
3. **COGS**: `eventType = 'procurement'` → negative amountEur, metadata.category = 'materials'
4. **Other Costs**: Other expense event types

**Amount Conventions:**
- Revenue (sales): Positive amounts (e.g., +1000.00)
- Expenses (payroll, COGS): Negative amounts (e.g., -500.00)
- Use `ABS()` when summing expenses for display
- Net calculations: revenue + expenses (since expenses are negative)

### Project Structure
[Source: docs/architecture/source-tree.md]

**File Locations:**
- **Query functions**: `lib/queries/finance-queries.ts` (create new)
- **API endpoint**: `app/api/views/finance/route.ts` (create)
- **Type definitions**: `types/api.ts` (update)
- **Test file**: `lib/queries/__tests__/finance-queries.test.ts`

### Tech Stack
[Source: docs/architecture/tech-stack.md]

Same stack as Story 2.1:
- TypeScript 5.3+ (strict mode)
- Prisma 5.7+ (aggregations)
- Next.js 14 API Routes
- Vitest for unit tests

### Coding Standards
[Source: docs/architecture/coding-standards.md]

**Financial Calculations:**
- Always use explicit parentheses: `(revenue - costs) / revenue * 100`
- Handle division by zero: `revenue === 0 ? 0 : margin`
- Comment financial formulas: `// Gross Margin = (Revenue - COGS) / Revenue * 100`

**Decimal Handling:**
```typescript
// Convert Prisma Decimal to number safely
const amount = Number(event.amountEur ?? 0)

// For expenses (negative values), use absolute value for display
const expense = Math.abs(Number(event.amountEur ?? 0))
```

### API Design Patterns
[Source: Story 2.1 implementation reference]

**Consistent API Response Structure:**
```typescript
// Finance View Response
{
  plSummary: {
    revenue: 50000.00,
    payroll: 15000.00,
    cogs: 8000.00,
    profit: 27000.00
  },
  monthlyCashFlow: [
    { month: "2024-01-01T00:00:00.000Z", cashIn: 12000, cashOut: 5000, netCash: 7000 }
  ],
  costBreakdown: {
    payroll: 15000.00,
    payrollPercent: 30.0,
    procurement: 8000.00,
    procurementPercent: 16.0,
    other: 2000.00,
    otherPercent: 4.0
  },
  marginAnalysis: {
    grossMargin: 84.0,  // (50000 - 8000) / 50000 * 100
    netMargin: 54.0     // 27000 / 50000 * 100
  }
}
```

### Financial Calculations Reference
[Source: docs/prd.md - FR5]

**P&L Summary Formula:**
```
Revenue = SUM(sales_transaction.amountEur)
Payroll = SUM(ABS(employee_lifecycle.amountEur)) where category='payroll'
COGS = SUM(ABS(procurement.amountEur)) where category='materials'
Other Costs = SUM(ABS(other_expense_events.amountEur))
Profit = Revenue - Payroll - COGS - Other Costs
```

**Margin Calculations:**
```
Gross Margin % = (Revenue - COGS) / Revenue * 100
Net Margin % = Profit / Revenue * 100

Handle edge case: if Revenue = 0, return 0 (not NaN or Infinity)
```

### Previous Story Insights
[Source: Story 1.8, Story 2.1]

**From Story 1.8 (Validation):**
- ✅ Revenue consistency validation already ensures Finance.revenue = Sales.revenue
- ✅ Use same Prisma query patterns for event aggregation
- ✅ Handle edge cases: zero amounts, null values, empty arrays

**From Story 2.1 (Sales View):**
- ✅ Use in-memory aggregation (simpler than Prisma groupBy)
- ✅ Parallel query execution with `Promise.all()` for performance
- ✅ Mock Prisma with `vi.mock('@/lib/db')` for tests
- ✅ API structure: GET with scenarioId query param

**Reusable Code Pattern:**
```typescript
// Pattern: Safe aggregation with null handling
const revenue = events
  .filter(e => e.eventType === 'sales_transaction')
  .reduce((sum, e) => sum + Number(e.amountEur ?? 0), 0)

// Pattern: Error handling in API route
try {
  const results = await Promise.all([
    getPLSummary(scenarioId),
    getMonthlyCashFlow(scenarioId),
    getCostBreakdown(scenarioId),
    getMarginAnalysis(scenarioId)
  ])
  return NextResponse.json({ ...results })
} catch (error) {
  console.error('Finance view query failed:', error)
  return NextResponse.json(
    { error: { message: 'Failed to fetch finance data', code: 'QUERY_ERROR' } },
    { status: 500 }
  )
}
```

### Cross-View Consistency
[Source: Story 1.8 - Mathematical Consistency Validation]

**Important:** Finance View revenue MUST match Sales View revenue (validated by Story 1.8).

Both views query `eventType = 'sales_transaction'` → same source of truth → guaranteed consistency.

**Verification Steps:**
1. Both Finance and Sales query same events table
2. Both filter by `eventType = 'sales_transaction'` for revenue
3. Both sum `amountEur` field
4. Story 1.8 validation ensures this reconciles perfectly

If discrepancy found, check:
- Query filters (should be identical)
- Amount handling (both use `Number(amountEur ?? 0)`)
- Event generation (Story 1.4-1.7 should produce consistent events)

### Testing

[Source: Story 2.1 testing approach]

**Test Framework**: Vitest with Prisma mocking

**Test File**: `lib/queries/__tests__/finance-queries.test.ts`

**Coverage Target**: 80%+ (consistent with Story 2.1)

**Key Test Cases:**
1. **P&L Calculations**: Verify revenue - costs = profit
2. **Cash Flow Segregation**: Positive vs negative amounts correctly split
3. **Cost Breakdown**: Category totals sum correctly
4. **Margin Formulas**: Gross and net margin calculations accurate
5. **Division by Zero**: revenue = 0 returns margin = 0 (not NaN)
6. **Negative Profit**: Handle losses (negative profit) correctly
7. **Empty Events**: Return zeros for all metrics

**Mock Pattern (from Story 2.1):**
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { prisma } from '@/lib/db'
import { Decimal } from '@prisma/client/runtime/library'
import { getPLSummary } from '../finance-queries'

vi.mock('@/lib/db', () => ({
  prisma: {
    event: {
      findMany: vi.fn()
    }
  }
}))

describe('Finance Queries', () => {
  it('should calculate P&L summary correctly', async () => {
    const mockEvents = [
      { eventType: 'sales_transaction', amountEur: new Decimal(10000) },
      { eventType: 'employee_lifecycle', amountEur: new Decimal(-3000), metadata: { category: 'payroll' } },
      { eventType: 'procurement', amountEur: new Decimal(-2000), metadata: { category: 'materials' } }
    ]
    vi.mocked(prisma.event.findMany).mockResolvedValue(mockEvents as any)

    const result = await getPLSummary('test')

    expect(result).toEqual({
      revenue: 10000,
      payroll: 3000,
      cogs: 2000,
      profit: 5000
    })
  })
})
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-18 | 1.0 | Initial story draft for Epic 2 | Bob (Scrum Master) |
