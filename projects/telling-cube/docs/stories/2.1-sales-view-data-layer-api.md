# Story 2.1: Sales View Data Layer & API

## Status
Draft

## Story
**As a** developer,
**I want** SQL query functions and an API endpoint that aggregate event data into Sales view metrics,
**so that** I can provide revenue, product, and customer analysis data to the frontend.

## Acceptance Criteria

1. Query utility file `lib/queries/sales-queries.ts` created with functions:
   - `getRevenueByMonth(scenarioId)`: Returns array of `{ month: Date, revenue: number }` aggregated from 'sale' events
   - `getRevenueByProduct(scenarioId)`: Returns array of `{ productId: string, revenue: number, unitsSold: number }`
   - `getTopCustomers(scenarioId, limit: number)`: Returns top N customers by total revenue
   - `getSalesTrendAnalysis(scenarioId)`: Returns month-over-month growth rates
2. All query functions use Prisma with proper type safety (no raw SQL in MVP)
3. API route `/api/views/sales` created accepting GET request with query param `scenarioId`
4. Endpoint returns JSON with structure: `{ revenueByMonth: [], revenueByProduct: [], topCustomers: [], trendAnalysis: {} }`
5. Manual test with generated scenario returns realistic aggregated data (verified via Postman or curl)

## Tasks / Subtasks

- [ ] Create Sales Query Utility Module (AC: 1, 2)
  - [ ] Create file `lib/queries/sales-queries.ts`
  - [ ] Import Prisma client and types: `import { prisma } from '@/lib/db'` and `import { Decimal } from '@prisma/client/runtime/library'`
  - [ ] Implement `getRevenueByMonth(scenarioId: string)` function
    - Query events where `eventType = 'sales_transaction'` and `scenarioId` matches
    - Group by `timePeriod` field (format: "2024-01")
    - Sum `amountEur` for each month
    - Return array sorted chronologically
  - [ ] Implement `getRevenueByProduct(scenarioId: string)` function
    - Query events where `eventType = 'sales_transaction'`
    - Group by `productId`
    - Calculate SUM(amountEur) as revenue and SUM(quantity) as unitsSold
    - Return array sorted by revenue descending
  - [ ] Implement `getTopCustomers(scenarioId: string, limit: number)` function
    - Query events where `eventType = 'sales_transaction'`
    - Group by `counterpartyId` (customer ID)
    - Calculate SUM(amountEur) as totalRevenue
    - Sort by totalRevenue descending
    - Limit to top N records
  - [ ] Implement `getSalesTrendAnalysis(scenarioId: string)` function
    - Use `getRevenueByMonth()` results
    - Calculate month-over-month % change: `(current - previous) / previous * 100`
    - Return object with avgGrowthRate, maxMonth, minMonth metrics
  - [ ] Add TypeScript return types for all functions (enforce type safety)
  - [ ] Add JSDoc comments documenting each function's purpose and return structure

- [ ] Create TypeScript Types for Sales View (AC: 4)
  - [ ] Create or update `types/api.ts` if it doesn't exist
  - [ ] Define `RevenueByMonth` interface: `{ month: Date; revenue: number }`
  - [ ] Define `RevenueByProduct` interface: `{ productId: string; revenue: number; unitsSold: number }`
  - [ ] Define `TopCustomer` interface: `{ counterpartyId: string; totalRevenue: number; transactionCount: number }`
  - [ ] Define `SalesTrendAnalysis` interface: `{ avgGrowthRate: number; maxMonth: string; minMonth: string }`
  - [ ] Define `SalesViewResponse` interface combining all above types

- [ ] Create Sales View API Endpoint (AC: 3, 4)
  - [ ] Create directory `app/api/views/sales/` if it doesn't exist
  - [ ] Create file `app/api/views/sales/route.ts`
  - [ ] Import Next.js Response utilities: `import { NextRequest, NextResponse } from 'next/server'`
  - [ ] Import sales query functions from `@/lib/queries/sales-queries`
  - [ ] Implement GET handler function `export async function GET(request: NextRequest)`
  - [ ] Extract `scenarioId` from URL search params: `request.nextUrl.searchParams.get('scenarioId')`
  - [ ] Validate scenarioId exists (return 400 if missing)
  - [ ] Call all 4 query functions in parallel using `Promise.all()` for performance
  - [ ] Construct response object matching `SalesViewResponse` interface
  - [ ] Return JSON response with 200 status
  - [ ] Add error handling: catch database errors and return 500 with error message
  - [ ] Add TypeScript types for request/response (no `any` types)

- [ ] Error Handling & Input Validation (AC: 3, 5)
  - [ ] Validate `scenarioId` format (UUID) using regex or Zod schema
  - [ ] Handle case where scenarioId doesn't exist in database (return empty arrays, not error)
  - [ ] Handle Prisma query errors gracefully (log error, return 500)
  - [ ] Add try-catch blocks around all Prisma operations
  - [ ] Test error cases: missing scenarioId, invalid UUID, nonexistent scenario

- [ ] Manual Testing & Verification (AC: 5)
  - [ ] Generate a Bakery scenario using `/api/generate` endpoint (capture scenarioId)
  - [ ] Test API endpoint: `curl http://localhost:3000/api/views/sales?scenarioId={uuid}`
  - [ ] Verify response structure matches `SalesViewResponse` interface
  - [ ] Verify revenue aggregations are mathematically correct (spot-check 1-2 months against raw events)
  - [ ] Verify top customers sorted correctly by revenue
  - [ ] Test with missing scenarioId (expect 400 error)
  - [ ] Test with invalid UUID (expect 400 error)
  - [ ] Test with nonexistent scenarioId (expect empty arrays, 200 status)

- [ ] Unit Tests (AC: 2, 5)
  - [ ] Create test file `lib/queries/__tests__/sales-queries.test.ts`
  - [ ] Mock Prisma client using `vi.mock('@/lib/db')`
  - [ ] Test `getRevenueByMonth()`: verify correct aggregation and sorting
  - [ ] Test `getRevenueByProduct()`: verify grouping by productId
  - [ ] Test `getTopCustomers()`: verify limit parameter works correctly
  - [ ] Test `getSalesTrendAnalysis()`: verify growth rate calculation
  - [ ] Test edge cases: empty events array, single event, null amounts
  - [ ] Run `pnpm test` and verify all tests pass

## Dev Notes

### Database Schema
[Source: prisma/schema.prisma]

**Event Model Fields (relevant for sales queries):**
- `id`: UUID primary key
- `scenarioId`: Foreign key to Scenario
- `eventType`: String - filter for `'sales_transaction'` for sales events
- `eventDate`: DateTime - individual transaction date
- `timePeriod`: String - format "2024-01" for month grouping (indexed)
- `productId`: String (nullable) - product identifier for revenue by product
- `counterpartyId`: String (nullable) - customer identifier for top customers analysis
- `amountEur`: Decimal(12,2) (nullable) - transaction amount in EUR
- `quantity`: Decimal(10,2) (nullable) - units sold
- `metadata`: JSON - flexible attributes (not used in MVP queries)

**Indexes available for query optimization:**
- `@@index([scenarioId, eventType])` - composite index for filtering sales events
- `@@index([scenarioId, timePeriod])` - composite index for monthly aggregations

### Project Structure
[Source: docs/architecture/source-tree.md]

**File Locations:**
- **Query functions**: `lib/queries/sales-queries.ts` (create new file)
- **API endpoint**: `app/api/views/sales/route.ts` (create new directory and file)
- **Type definitions**: `types/api.ts` (create or update)
- **Test file**: `lib/queries/__tests__/sales-queries.test.ts`

**Import alias**: Use `@/` to reference root directory (configured in tsconfig.json)

### Tech Stack
[Source: docs/architecture/tech-stack.md]

**Backend Stack:**
- **Language**: TypeScript 5.3+ (strict mode enabled)
- **Framework**: Next.js 14 API Routes (serverless functions)
- **ORM**: Prisma 5.7+ (type-safe database access)
- **Database**: NeonDB (PostgreSQL 15+)
- **Testing**: Vitest (for unit tests, already used in Story 1.8)

**Key Technologies:**
- Prisma aggregations: `groupBy()`, `aggregate()` for SUM operations
- Next.js API Routes: `route.ts` convention for GET/POST handlers
- TypeScript: Strict mode with no `any` types in query functions

### Coding Standards
[Source: docs/architecture/coding-standards.md]

**Naming Conventions:**
- **Functions**: camelCase (`getRevenueByMonth`)
- **Types/Interfaces**: PascalCase (`SalesViewResponse`)
- **Files**: kebab-case for utilities (`sales-queries.ts`), `route.ts` for API endpoints

**TypeScript Rules:**
- ✅ Explicit return types for exported functions (required)
- ✅ No `any` types (ESLint warning)
- ✅ Strict null checks enabled

**Error Handling:**
- Always use try-catch blocks for async operations
- Log errors with `console.error()`
- Return structured error responses: `{ error: { message: string, code: string } }`

**Import Order:**
1. React/Next.js
2. External libraries (Prisma, Zod)
3. Internal utilities (`@/lib/...`)
4. Types (`type` imports)

### API Design Patterns
[Source: docs/prd.md - Technical Assumptions]

**REST API Conventions:**
- **Method**: GET for data retrieval
- **Query params**: Use `?scenarioId=uuid` for filtering
- **Response format**: JSON with top-level data structure
- **Error responses**: Consistent structure with `error` object
- **Status codes**: 200 (success), 400 (bad request), 500 (server error)

**Example API Response Structure:**
```typescript
{
  revenueByMonth: [
    { month: "2024-01-01T00:00:00.000Z", revenue: 12500.50 },
    { month: "2024-02-01T00:00:00.000Z", revenue: 14200.00 }
  ],
  revenueByProduct: [
    { productId: "prod-001", revenue: 8000.00, unitsSold: 1200 },
    { productId: "prod-002", revenue: 5500.50, unitsSold: 850 }
  ],
  topCustomers: [
    { counterpartyId: "cust-042", totalRevenue: 3500.00, transactionCount: 12 }
  ],
  trendAnalysis: {
    avgGrowthRate: 12.5,
    maxMonth: "2024-06",
    minMonth: "2024-01"
  }
}
```

### Prisma Query Patterns
[Source: docs/architecture/tech-stack.md, Story 1.8 implementation reference]

**Aggregation Example (from Story 1.8):**
```typescript
// Pattern used successfully in consistency-validator.ts
const events = await prisma.event.findMany({
  where: {
    scenarioId,
    eventType: 'sales_transaction'
  },
  orderBy: { eventDate: 'asc' }
})

// In-memory aggregation (simpler than Prisma groupBy for MVP)
const revenueByMonth = events.reduce((acc, event) => {
  const month = event.timePeriod
  if (!acc[month]) acc[month] = 0
  acc[month] += Number(event.amountEur ?? 0)
  return acc
}, {} as Record<string, number>)
```

**Why in-memory vs Prisma groupBy:**
- Simpler for MVP (fewer Prisma quirks)
- Events are already indexed and filtered efficiently
- 150-300 events per scenario = minimal memory footprint
- Can switch to Prisma `groupBy()` post-MVP if needed

### Performance Considerations
[Source: docs/prd.md - NFR6, NFR8]

**Query Performance Target**: <200ms for view aggregations (NFR specification)

**Optimization Strategies:**
- Use composite indexes: `@@index([scenarioId, eventType])` already exists
- Filter early: Apply `where` clauses before fetching data
- Parallel execution: Use `Promise.all()` for independent queries
- Limit data: Use `select` to fetch only needed fields (if query is slow)

**Expected Data Volume**: 150-300 events per scenario (manageable for in-memory aggregation)

### Previous Story Insights
[Source: Story 1.8 QA Results]

**Learnings from Story 1.8 (Mathematical Consistency Validation):**
- ✅ **Prisma mocking pattern**: Use `vi.mock('@/lib/db')` for isolated unit tests
- ✅ **Decimal handling**: Convert Prisma Decimal to number using `Number(event.amountEur ?? 0)`
- ✅ **Edge case handling**: Handle null amounts, empty events arrays, missing metadata
- ✅ **Test coverage standard**: 90%+ statement coverage achieved (excellent for critical logic)
- ✅ **Error handling pattern**: Try-catch with structured ValidationResult return type

**Reusable Patterns:**
```typescript
// Pattern 1: Safe Decimal conversion
const revenue = events.reduce((sum, e) => sum + Number(e.amountEur ?? 0), 0)

// Pattern 2: Error handling
try {
  const events = await prisma.event.findMany({ ... })
  return { success: true, data: processedData }
} catch (error) {
  console.error('Query failed:', error)
  return { success: false, error: error.message }
}

// Pattern 3: Vitest + Prisma mocking
vi.mock('@/lib/db', () => ({
  prisma: {
    event: {
      findMany: vi.fn()
    }
  }
}))
```

### Testing

[Source: docs/architecture/tech-stack.md, Story 1.8 implementation]

**Test Framework**: Vitest (already configured in `vitest.config.ts`)

**Test File Location**: `lib/queries/__tests__/sales-queries.test.ts`

**Testing Strategy**:
- **Unit tests**: Test query functions in isolation using mocked Prisma client
- **Coverage target**: 80%+ for query functions (not as critical as validation logic)
- **Test cases to cover**:
  1. Happy path: Valid scenarioId with multiple events
  2. Edge case: Empty events array (new scenario)
  3. Edge case: Single event
  4. Edge case: Null amounts (handle gracefully)
  5. Edge case: Missing productId/counterpartyId (filter out or handle)
  6. Aggregation correctness: Verify SUM calculations match expected results

**Mock Pattern**:
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { prisma } from '@/lib/db'
import { Decimal } from '@prisma/client/runtime/library'
import { getRevenueByMonth } from '../sales-queries'

vi.mock('@/lib/db', () => ({
  prisma: {
    event: {
      findMany: vi.fn()
    }
  }
}))

describe('Sales Queries', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('should aggregate revenue by month correctly', async () => {
    const mockEvents = [
      { id: '1', scenarioId: 'test', eventType: 'sales_transaction', timePeriod: '2024-01', amountEur: new Decimal(1000) },
      { id: '2', scenarioId: 'test', eventType: 'sales_transaction', timePeriod: '2024-01', amountEur: new Decimal(500) },
      { id: '3', scenarioId: 'test', eventType: 'sales_transaction', timePeriod: '2024-02', amountEur: new Decimal(2000) }
    ]
    vi.mocked(prisma.event.findMany).mockResolvedValue(mockEvents as any)

    const result = await getRevenueByMonth('test')

    expect(result).toEqual([
      { month: '2024-01', revenue: 1500 },
      { month: '2024-02', revenue: 2000 }
    ])
  })
})
```

**Run Tests**:
```bash
pnpm test                    # Run all tests
pnpm test sales-queries      # Run only sales query tests
pnpm test --coverage         # Run with coverage report
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-18 | 1.0 | Initial story draft for Epic 2 | Bob (Scrum Master) |
