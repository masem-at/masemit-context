# Story 1.2: Database Schema & Connection Setup

## Status
Done

## Story
**As a** developer,
**I want** a PostgreSQL database with Prisma ORM and the ephemeral event storage schema,
**so that** I can store and query session-based business event data efficiently with automatic 24-hour cleanup.

## Acceptance Criteria
1. NeonDB project created and connection string stored in `.env.local` (not committed to Git)
2. Prisma initialized with `schema.prisma` containing Scenario and Event models matching architecture specification (session-based with 24-hour TTL via `expiresAt` field)
3. Initial Prisma migration created and applied successfully to NeonDB (scenarios and events tables exist with proper indexes and cascade delete)
4. Test API route (`/api/test-db`) successfully inserts a sample scenario with events, queries it back, and returns the result as JSON
5. Database connection error handling implemented (returns meaningful error if DATABASE_URL missing or invalid)

## Tasks / Subtasks

- [ ] Set up NeonDB and configure environment (AC: 1)
  - [ ] Create NeonDB project via dashboard (Frankfurt region)
  - [ ] Copy connection string to `.env.local` as `DATABASE_URL`
  - [ ] Verify `.env.local` is in `.gitignore`
  - [ ] Test connection string format matches: `postgresql://user:password@ep-xxx.eu-central-1.aws.neon.tech/tellingcube?sslmode=require`

- [ ] Initialize Prisma with schema definition (AC: 2)
  - [ ] Install Prisma dependencies: `pnpm add -D prisma` and `pnpm add @prisma/client`
  - [ ] Run `npx prisma init` to create `prisma/schema.prisma`
  - [ ] Define Scenario model with all fields (id, scenarioType, status, metadata, validation, timestamps with `expiresAt` for 24hr TTL)
  - [ ] Define Event model with all fields (id, scenarioId, eventType, eventDate, dimensions, financial attributes, JSON metadata)
  - [ ] Add relationship: Event belongs to Scenario with `onDelete: Cascade`
  - [ ] Add indexes: Scenario (status, expiresAt, createdAt), Event (scenarioId, eventType, eventDate, timePeriod, composite indexes)
  - [ ] Verify schema matches architecture document exactly

- [ ] Create and apply initial migration (AC: 3)
  - [ ] Run `npx prisma migrate dev --name init` to create migration
  - [ ] Verify migration file created in `prisma/migrations/`
  - [ ] Confirm migration applied successfully to NeonDB
  - [ ] Run `npx prisma generate` to generate Prisma Client
  - [ ] Verify tables exist in NeonDB dashboard: `scenarios`, `events`
  - [ ] Check indexes created: `status`, `expiresAt`, `scenarioId`, `eventType`, etc.

- [ ] Create test API route for database validation (AC: 4)
  - [ ] Create `/app/api/test-db/route.ts` with POST handler
  - [ ] Implement test scenario insertion with `expiresAt` set to 24 hours from now
  - [ ] Insert 3 sample events linked to test scenario
  - [ ] Query back scenario with events using Prisma `include`
  - [ ] Return JSON response: `{ success: true, scenario: {...}, eventCount: number }`
  - [ ] Test route locally: `curl -X POST http://localhost:3000/api/test-db`

- [ ] Implement database connection error handling (AC: 5)
  - [ ] Wrap Prisma client initialization in try-catch
  - [ ] Check for missing `DATABASE_URL` environment variable
  - [ ] Return user-friendly error message if connection fails
  - [ ] Add error response: `{ error: "Database connection failed", details: "..." }`
  - [ ] Test error handling: temporarily break DATABASE_URL and verify error message

## Dev Notes

### PoC Scope: Session-Based Ephemeral Storage

**CRITICAL:** This story implements **session-based, ephemeral data storage** for the PoC "Brother" release. Key principles:
- **NO user authentication or user accounts** (FR8, NFR6 from PRD)
- **NO persistent user data** beyond 24-hour session window
- **Focus:** Scenario + Event models ONLY (no User, Auth, or persistent Export tables)
- **24-hour TTL:** `expiresAt` field on Scenario triggers automatic cleanup (implemented in future story via cron)

[Source: PRD FR8, NFR6; Architecture "PoC Scope"]

### Database Platform & Configuration

**Database:** NeonDB Launch tier (serverless PostgreSQL)
- **Region:** Frankfurt (`eu-central-1`) - closest to Austria for low latency
- **Connection String Format:**
  ```
  postgresql://user:password@ep-xxx.eu-central-1.aws.neon.tech/tellingcube?sslmode=require
  ```
- **Auto-scaling:** Scales to zero when idle (cost optimization)
- **Prisma Compatible:** Full PostgreSQL compatibility

[Source: Architecture Section "Platform and Infrastructure Choice"]

### Prisma Schema Models

**File Location:** `prisma/schema.prisma`

#### Scenario Model (Metadata Container)

```prisma
model Scenario {
  id                String    @id @default(uuid())
  scenarioType      String    // 'bakery' | 'hotel' | 'tech_startup'
  status            String    @default("processing") // 'processing' | 'completed' | 'error'

  // Metadata
  companyName       String?
  employeeCount     Int?
  timePeriodStart   DateTime
  timePeriodEnd     DateTime

  // Validation
  validationPassed  Boolean   @default(false)
  validationErrors  String[]  @default([])

  // Timestamps
  createdAt         DateTime  @default(now())
  completedAt       DateTime?
  expiresAt         DateTime  // 24 hours from createdAt

  // Relationships
  events            Event[]

  // Indexes
  @@index([status])
  @@index([expiresAt])
  @@index([createdAt])

  @@map("scenarios")
}
```

**Key Fields:**
- `expiresAt`: **24-hour TTL field** - set to `createdAt + 24 hours`. Used by cleanup cron job (future story)
- `status`: Tracks generation progress (processing → completed/error)
- `validationPassed`: Boolean flag for mathematical consistency validation

[Source: Architecture "Data Models" Section, "Database Schema"]

#### Event Model (Core Event-Sourcing Model)

```prisma
model Event {
  id                String    @id @default(uuid())
  scenarioId        String
  eventType         String    // EventType enum
  eventDate         DateTime

  // Dimensions (standardized across all events)
  timePeriod        String    // "2024-01" format for grouping
  organizationUnit  String?
  productId         String?
  counterpartyId    String?   // Customer, employee, or supplier ID
  assetId           String?

  // Financial attributes (nullable - only for financial events)
  amountEur         Decimal?  @db.Decimal(12, 2)
  quantity          Decimal?  @db.Decimal(10, 2)
  unitPrice         Decimal?  @db.Decimal(10, 2)

  // Metadata (flexible JSON for event-specific attributes)
  metadata          Json      @default("{}")

  createdAt         DateTime  @default(now())

  // Relationships
  scenario          Scenario  @relation(fields: [scenarioId], references: [id], onDelete: Cascade)

  // Indexes for query performance
  @@index([scenarioId])
  @@index([eventType])
  @@index([eventDate])
  @@index([timePeriod])
  @@index([scenarioId, eventType])
  @@index([scenarioId, timePeriod])

  @@map("events")
}
```

**Key Fields:**
- `scenarioId`: Foreign key to Scenario with **`onDelete: Cascade`** (when Scenario deleted, all Events deleted)
- `eventType`: One of 7 event types (employee_lifecycle, sales_transaction, cash_movement, operational_work, procurement, asset_lifecycle, planning_budgeting)
- `amountEur`: Uses `Decimal` type for precision (avoid floating-point errors in financial calculations)
- `metadata`: Flexible JSON field for event-specific attributes (AI-friendly, no schema migrations needed)

[Source: Architecture "Data Models", "Database Schema"]

### Event Types (Reference)

```typescript
enum EventType {
  EMPLOYEE_LIFECYCLE = 'employee_lifecycle',
  SALES_TRANSACTION = 'sales_transaction',
  CASH_MOVEMENT = 'cash_movement',
  OPERATIONAL_WORK = 'operational_work',
  PROCUREMENT = 'procurement',
  ASSET_LIFECYCLE = 'asset_lifecycle',
  PLANNING_BUDGETING = 'planning_budgeting'
}
```

[Source: Architecture "Data Models" Section]

### Database Indexes (Performance Optimization)

**Scenario Indexes:**
- `status`: For filtering active/completed scenarios
- `expiresAt`: **Critical for cleanup cron job** (query expired scenarios)
- `createdAt`: For sorting recent scenarios

**Event Indexes:**
- `scenarioId`: Foreign key index (fast joins)
- `eventType`: Filter events by type (e.g., "show me all sales events")
- `eventDate`: Chronological queries
- `timePeriod`: Group events by month (e.g., "January 2024")
- Composite `[scenarioId, eventType]`: Fast queries like "all sales events for scenario X"
- Composite `[scenarioId, timePeriod]`: Monthly aggregations for a scenario

[Source: Architecture "Database Schema"]

### Project Structure (Database Files)

```
/telling-cube
├── /prisma
│   ├── schema.prisma           # Prisma schema definition
│   └── /migrations
│       └── /[timestamp]_init   # Initial migration (auto-generated)
├── /app/api
│   └── /test-db
│       └── route.ts            # Test API route for DB validation
├── .env.local                  # DATABASE_URL (not committed)
└── .env.local.example          # Template (already exists from Story 1.1)
```

[Source: Architecture "Repository Structure"]

### Environment Variables

**File:** `.env.local` (already exists from Story 1.1)

Add to existing file:
```bash
# Database (NeonDB PostgreSQL)
DATABASE_URL="postgresql://user:password@ep-xxx.eu-central-1.aws.neon.tech/tellingcube?sslmode=require"
```

**File:** `.env.local.example` (update with database info)

```bash
# Database
# NeonDB PostgreSQL connection string
# Format: postgresql://user:password@ep-xxx.eu-central-1.aws.neon.tech/tellingcube?sslmode=require
DATABASE_URL="postgresql://user:password@host/database"
```

[Source: Architecture "Database Schema", "Environment Variables"]

### Prisma Client Usage Pattern

```typescript
// lib/db.ts - Singleton Prisma Client (recommended pattern)
import { PrismaClient } from '@prisma/client'

const globalForPrisma = global as unknown as { prisma: PrismaClient }

export const prisma =
  globalForPrisma.prisma ||
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  })

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma
```

**Usage in API routes:**
```typescript
import { prisma } from '@/lib/db'

// Create scenario with 24-hour TTL
const scenario = await prisma.scenario.create({
  data: {
    scenarioType: 'bakery',
    status: 'processing',
    timePeriodStart: new Date('2024-01-01'),
    timePeriodEnd: new Date('2024-12-31'),
    expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours from now
  },
})
```

[Source: Architecture "Backend Architecture" - Prisma best practices]

### Design Rationale (Event-Sourcing Architecture)

**Why single Events table?**
- Simpler queries (no UNIONs across multiple event type tables)
- Easier AI generation (Claude generates events to one schema)
- Consistent schema (standardized dimensions across all event types)
- Prisma-friendly (single model, single migration)

**Why JSON metadata field?**
- Flexibility for new event types (no schema migrations needed)
- AI-friendly (Claude can output arbitrary JSON attributes)
- Self-documenting (metadata contains event-specific context)

**Why Decimal for currency?**
- Precision (avoid floating-point errors in financial calculations)
- IBCS compliance (exact reconciliation required for multi-view consistency)
- Validation requires exact matching (Finance revenue must equal sum of Sales events)

**Why 24-hour TTL?**
- MVP simplicity (no user accounts, no long-term storage)
- Cost control (automatic cleanup prevents database bloat)
- Privacy-friendly (data doesn't persist indefinitely)
- Matches ephemeral UX (users don't expect permanent storage in PoC)

[Source: Architecture "Data Models" - Design Rationale]

### Testing

**Manual Testing Checklist:**
1. ✅ Prisma schema compiles without errors: `npx prisma validate`
2. ✅ Migration creates tables in NeonDB: Check dashboard for `scenarios`, `events` tables
3. ✅ Indexes exist in NeonDB: Verify via dashboard SQL query or `\d scenarios` in psql
4. ✅ Test API route returns success: `curl -X POST http://localhost:3000/api/test-db`
5. ✅ Scenario includes events in response (Prisma `include` works)
6. ✅ Cascade delete works: Delete scenario, verify events also deleted
7. ✅ Error handling: Break DATABASE_URL, verify friendly error message
8. ✅ expiresAt field set to 24 hours in future (check returned JSON timestamp)

**No automated tests required for Story 1.2** (database setup story - tested via manual verification and test API route)

[Source: Story 1.1 pattern - PoC testing is manual]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-16 | 1.0 | Initial story creation from PRD Epic 1, Story 1.2 | Bob (SM) |
| 2025-11-16 | 1.1 | Story approved for development | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
_To be populated by Dev Agent_

### Debug Log References
_To be populated by Dev Agent_

### Completion Notes List
_To be populated by Dev Agent_

### File List
_To be populated by Dev Agent_

## QA Results
_To be populated by QA agent_
